<!DOCTYPE html>
<html>
<head>
    <title>VR Optics</title>
    <style>
        /* CSS for tutorial layout */
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 10px;
            max-width: 900px; /* Configurable maximum width */
            margin: 0 auto; /* Center the content */
            background-color: #f0f0f0;
        }

        #tutorial-container {
            display: flex;
            background-color: #ffffff;
            border-radius: 10px;
            box-shadow: 0 5px 10px rgba(0, 0, 0, 0.1);
        }

        #tutorial-navigation {
            flex: 0 0 120px;
            border-radius: 10px 0 0 10px;
            background-color: #eeeeee;
            padding: 15px;
        }

        ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        li {
            border-radius: 5px;
            background-color: #DDDDDD;
            border: 1px solid #666666;
            padding: 2px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            text-align: center;
        }
        
        li:hover {
            background-color: #EEEEEE;
            box-shadow: 0 5px 10px rgba(0, 0, 0, 0.1);
            transition: box-shadow 0.5s ease;
            transition: background-color 0.5s ease;
        }

        a {
            color: #333333;
            text-decoration: none;
            transition: color 0.3s ease;
        }

        a:hover {
            color: #666666;
        }

        #tutorial-content {
            flex: 1;
            padding: 20px;
        }

        h2 {
            margin-top: 0;
            color: #333333;
            font-size: 24px;
            font-weight: 700;
        }

        p {
            margin-bottom: 15px;
            color: #666666;
        }

        pre {
            width: 96%;
            font-family: "Courier New", monospace;
            font-size: 18px;
            background-color: #eeeeee;
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 10px;
            color: #333333;
        }

        .input-container {
            margin-bottom: 10px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            color: #333333;
            font-weight: 600;
        }

        input {
            width: 96%;
            padding: 10px;
            font-size: 16px;
            border: 1px solid #ccc;
            border-radius: 5px;
        }

        .button-container {
            text-align: center;
            margin-top: 20px;
        }

        .button-container button {
            padding: 12px 24px;
            font-size: 16px;
            background-color: #007bff;
            color: #ffffff;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.5s ease;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }

        .button-container button:hover {
            background-color: #0056b3;
            box-shadow: 0 5px 10px rgba(0, 0, 0, 0.1);
            transition: box-shadow 0.5s ease;
            transition: background-color 0.5s ease;
        }

        .button-container button:disabled {
            cursor: not-allowed;
            opacity: 0.3; /* Reduced opacity for disabled buttons */
        }

        .disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }

        .distinct-link {
            padding: 5px;
            transition: box-shadow 0.5s ease;
            transition: background-color 0.5s ease;
        }

        .body-link {
            font-size: 14px;
            border: 1px;
            border-style: hidden;
            border-bottom-style: dotted;
            border-radius: 5px;
            background-color: #e8f3ff;
            transition: box-shadow 0.5s ease;
            transition: background-color 0.5s ease;
        }

        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div id="tutorial-container">
        <div id="tutorial-navigation">
            <ul>
                <a href="#section-1" onclick="navigateToSection(1)" class="distinct-link" id="link-1"><li>Introduction</li></a>
                <a href="#section-2" onclick="navigateToSection(2)" class="distinct-link" id="link-2"><li>Eye Relief<br>and Lenses</li></a>
                <a href="#section-3" onclick="navigateToSection(3)" class="distinct-link" id="link-3"><li>Magnification<br>and The<br>Thin-Lens<br>Equation</li></a>
				<a href="hmdgeometry.html"><li><i><b>More to come,</b></i><br>but for now,<br>please check out the old<br>HMD Geometry Visualizer</li></a>
            </ul>
        </div>
        <div id="tutorial-content">
            <section id="section-1" class="tutorial-section">
                <h2>Optics of Stereoscopic Head-Mounted Displays</h2>
                <p>
                    Intended for enthusiasts, this collection of tools aims to help in selecting 
                    lenses and displays for custom VR headsets and other head-mounted displays. It also 
                    enables users to analyze crucial attributes of their HMDs by finding 
                    characteristics such as field of view and angular pixel density.
                </p>
                <p>
                    All of this is based on basic geometry and the thin-lens equation. This is not a 
                    tutorial, some knowledge of the topics at hand is required to take full advantage of these tools.
                    Results may not be applicable to all arrangements. Lenses can be incredibly
                    complex systems, whereas the assumptions made here are all based on the simplest
                    biconvex thin-lens form. VR headsets can feature attributes beyond what is accounted
                    for here, such rotated, canted, or tilted displays, lenses with other geometries,
                    and bespoke optics designed specifically for VR or AR applications. Take it all 
                    with a grain of salt. 
                </p>
                <p>
                    Manufacturers use a variety of methods to measure attributes of their head-mounted displays. 
                    Few manufacturers provide insights into their metrology, and there is no consensus or 
                    standardized approach for measuring either FOV or PPD of a head-mounted display. Many resort 
                    to cherry-picking attributes in order to make their products appear more competitive. Many 
                    simply fail to deliver information about their headset geometry beyond simple FOV and PPD figures
                    given without context or description, and actually applying any additional information can be a 
                    challenge in itself. All of this makes it difficult for consumers to make well-informed decisions.
                </p>
                <p>
                    Huge thanks to the folks who make invaluable resources freely available online.
                    In making this I frequently referenced Steven LaValle's 
                    <a class="body-link" href="http://lavalle.pl/vr/vrch4.pdf">"Virtual Reality"</a>,
                    the slideshows from <a class="body-link" href="https://stanford.edu/class/ee267/">
                    Stanford's EE267</a>, and a variety of classes from <a class="body-link" href="https://www.khanacademy.org/">Khan Academy</a>.
                    If you'd like to learn more and expand your knowledge beyond what can be gleaned here,
                    I highly recommend exploring these and other online resources.
                    Khan Academy is always worth noting, their content is free and much of it is 
                    available in a variety of languages, including translated transcripts of video resources. 
                    Consider their unit on <a class="body-link" href="https://www.khanacademy.org/science/physics/geometric-optics">Geometric Optics</a>
                    and the more in-depth <a class="body-link" href="https://www.khanacademy.org/science/in-in-class-12th-physics-india/in-in-ray-optics-and-optical-instruments">Ray Optics and Optical Instruments</a>.
                    They make a great starting point for exploring optics and lenses in greater detail.
                </p>
            </section>
            <section id="section-2" class="tutorial-section hidden">
                <h2>Eye Relief and Lenses:</h2>
                <p>
                    Eye Relief is the distance between the lens and the user's eye.
                    When measuring eye relief we consider the lens plane, or vertical axis of the lens perpendicular to the principle axis.
                    That is, we measure from the middle of the lens, not the outer surface.
                </p>
                <p>
                    Eye Relief and Lens Size impose constraints on the maximum attainable field of view in 
                    a VR headset. The concept is straightforward: for the lens to display to the user
                    a particular field of view, the lens itself must encompass at least that same field 
                    of view of the eye.
                </p>
                <img src="imgs\eyeRelief.png" alt="Eye Relief" class="tutorial-image">
                <p>We can calculate the maximum Eye Relief for a given Lens Diameter and FOV:</p>
                <pre>Max Eye Relief = Lens Diameter&divide;(2&times;tan(FOV_radians&divide;2))</pre>
                <div class="input-container">
                    <label for="lensD2">Enter Lens Diameter (mm):</label>
                    <input id="lensD2" type="text" class="lens-diameter">
                </div>
                <div class="input-container">
                    <label for="fov2">Enter Desired FOV (degrees):</label>
                    <input id="fov2" type="text" class="fov-input">
                    <div id="output-eyeRelief2"></div>
                </div>
                <div class="button-container">
                    <button onclick="calculateEyeRelief()">Calculate Eye Relief</button>
                </div>
                <p>
                    We can also go the other direction with it and calculate the maximum field of view
                    for a given lens diameter and Eye Relief:
                </p>
                <pre>Max FOV_radians = 2&times;atan(Lens Diameter&divide;(2&times;Eye Relief))</pre>
                <div class="input-container">
                    <label for="lensD2_2">Enter Lens Diameter (mm):</label>
                    <input id="lensD2_2" type="text" class="lens-diameter">
                </div>
                <div class="input-container">
                    <label for="eyeR2">Enter Desired Eye Relief (mm):</label>
                    <input id="eyeR2" type="text" class="eyeR-input">
                    <div id="output-fov2"></div>
                </div>
                <div class="button-container">
                    <button onclick="calculateFOVbyEyeRelief()">Calculate FOV</button>
                </div>
                <p>
                    This is just basic trigonometry relating to isosceles triangles. In the first example, 
                    we find the height to the apex of an isosceles triangle using the base length and the vertex angle.
                    The second example is switched around, determining the vertex angle given the base 
                    length and height to the apex.
                </p>
            </section>
            <section id="section-3" class="tutorial-section hidden">
                <h2>Magnification and The Thin-Lens Equation:</h2>
                <p>
                    Lenses have two main functions in a head-mounted display: to magnify the display
                    to cover a large field of view, and to displace the image to a focal distance that is
                    comfortable for the eyes to focus on. The effects are a relationship between the lens focal 
                    length, the dimensions of the display, and the distance from the display to the lens. 
                    This relationship can be described by the Magnification and Thin-lens Equations.
                </p>
                <p>
                    Focal Length is the given focal length of a lens, the distance at which parallel rays passing through the lens will then intersect.
                    If you've ever used a magnifying glass to focus the sun to a small point in order to burn or melt objects, then you've observed focal length.
                </p>
                <p>
                    Object Distance is the distance between the lens plane and the observed object, which is the display or displays in a VR headset.
                </p>
                <p>
                    Image Distance is the distance between the lens plane and the observed image, the distance at which an object appears to be when
                    viewed through a lens. In the context of VR headsets this is typically referred to as Focal Depth, describing the distance from the lens to the Focal Plane, 
                    and is a fixed distance chosen by the designer. The Focal Depth is the inverse of the Image Distance, as Image Distance in this context will always be
                    a negative value.
                </p>
                <p>
                    For VR headsets specifically, the Focal Depth is typically in the range of 1.5 to 2.0 meters. 
                    This isn't ideal, but it is currently a limitation of most head-mounted displays. 
                    <a class="body-link" href="https://en.wikipedia.org/wiki/Vergence-accommodation_conflict">Read more about the Vergence-accommodation Conflict.</a>
                    The 1.5-2.0 meter range is a comfortable viewing distance for most users, it's a range that is comfortable to focus on for long periods of time,
                    and accommodates a wide range of users with myopia and/or hyperopia. Too close or too far could increase eye strain, exclude more users without ideal vision,
                    or impact the sense of scale. For specialized head-mounted displays, lengths outside this range have been used. Some head-mounted displays intended
                    specifically for reading may have a Focal Depth less than 1 meter away, whereas some FPV displays have a Focal Depth in excess of 3 meters.
                </p>
                <pre>Magnification = -(Image Distance)&divide;Object Distance<br>1&divide;Focal Length = (1&divide;Image Distance) + (1&divide;Object Distance)</pre>
                <pre>Object Distance = 1&divide;((1&divide;Focal Length) - (1&divide;Image Distance))</pre>
                <div class="input-container">
                    <label for="lensF3">Enter Lens Focal Length (mm):</label>
                    <input id="lensF3" type="text" class="lens-focus">
                </div>
                <div class="input-container">
                    <label for="focal3">Enter Desired Focal Depth (mm):</label>
                    <input id="focal3" type="text" class="image-distance">
                    <div id="output-objectDistance"></div>
                </div>
                <div class="button-container">
                    <button onclick="calculateObjectDistance()">Calculate Object Distance</button>
                </div>
                <pre>Image Distance = 1&divide;((1&divide;Focal Length) - (1&divide;Object Distance))</pre>
                <div class="input-container">
                    <label for="lensF32">Enter Lens Focal Length (mm):</label>
                    <input id="lensF32" type="text" class="lens-focus">
                </div>
                <div class="input-container">
                    <label for="object3">Enter Object Distance (mm):</label>
                    <input id="object3" type="text" class="object-distance">
                    <div id="output-imageDistance"></div>
                </div>
                <div class="button-container">
                    <button onclick="calculateImageDistance()">Calculate Image Distance</button>
                </div>
                
            </section>
        </div>
    </div>

    <script src="./hmd.js"></script>
    <script>
        // JavaScript code to handle calculations and display results

        let currentSection = 1;
        const sectionCount = 3;

        const in_objectDistance = document.querySelectorAll('.object-distance');
        const in_imageDistance  = document.querySelectorAll('.image-distance');
        const in_span           = document.querySelectorAll('.input-span');
        const in_distance       = document.querySelectorAll('.input-distance');
        const in_lensD          = document.querySelectorAll('.lens-diameter');
        const in_lensF          = document.querySelectorAll('.lens-focus');
        const in_fov            = document.querySelectorAll('.fov-input');
        const in_eyeR           = document.querySelectorAll('.eyeR-input');

        let oD = 0;
        let iD = 0;
        let span = 0;
        let distance = 0;
        let lensD = 0;
        let lensF = 0;
        let fov = 0;
        let eyeR = 0;

        function navigateToSection(section) {
            setTimeout(()=> {
                scrollTo({left:0, top:0, behavior:'smooth'});
            }, 100);
            if (section >= 1 && section <= sectionCount) {
                const targetSectionElement = document.getElementById(`section-${section}`);
                document.getElementById(`section-${currentSection}`).classList.add('hidden');
                document.getElementById(`section-${section}`).classList.remove('hidden');
                currentSection = section;
                updateButtonStates();
            }
        }

        function updateButtonStates() {
            document.getElementById('previous-button').disabled = currentSection === 1;
            document.getElementById('next-button').disabled = currentSection === sectionCount;
        }
        
        window.addEventListener('load', () => {
            const hash = window.location.hash;
            if (hash) {
              const section = parseInt(hash.substr(1).split('-')[1]);
              navigateToSection(section);
            }
        });

        function calculateEyeRelief() {
            const relief = tl.occlusionDistance(lensD, fov).toFixed(2);
            const fov_rad = tl.deg2rad(fov).toFixed(2);
            if (relief != 'NaN'){
                document.getElementById('output-eyeRelief2').innerHTML = `<pre>${fov}&deg; in radians = ${fov_rad}<br>Maximum Eye Relief = ${lensD}mm &divide; (2&times;tan(${fov_rad}&divide;2))<br>Maximum Eye Relief = ${relief}mm</pre>`;
            }
        }
        
        function calculateFOVbyEyeRelief() {
            const cfov = tl.angularSize(lensD, eyeR).toFixed(2);
            const fov_rad = tl.deg2rad(tl.angularSize(lensD, eyeR)).toFixed(2);
            if (fov != 'NaN'){
                document.getElementById('output-fov2').innerHTML = `<pre>Maximum FOV_radians = 2&times;atan(${lensD}mm&divide;(2&times;${eyeR}mm))<br>Maximum FOV_radians = ${fov_rad}<br>Maximum FOV = ${cfov}&deg;</pre>`;
            }
        }

        function calculateObjectDistance() {
            oD = tl.rDistance(-iD, lensF).toFixed(2);
            document.getElementById('output-objectDistance').innerHTML = `<pre>Object Distance = 1&divide;((1&divide;${lensF}) - (1&divide; -${iD}))<br>Object Distance = ${oD}mm</pre>`;
        }

        function calculateImageDistance() {
            iD = tl.rDistance(oD, lensF).toFixed(2);
            document.getElementById('output-imageDistance').innerHTML = `<pre>Image Distance = 1&divide;((1&divide;${lensF}) - (1&divide;${oD}))<br>Image Distance = ${iD}mm<br>Focal Depth = ${-iD}mm</pre>`;
        }

        function calculateMagnification() {
            const magnification = tl.Mag(iD, oD);
            document.getElementById('output-magnification').textContent = `Magnification: ${magnification}`;
        }

        function calculateFocalLength() {
            const focalLength = tl.focalLength(oD, iD);
            document.getElementById('output-focal-length').textContent = `Focal Length: ${focalLength}`;
        }

        function calculateAngularSize() {
            const angularSize = tl.angularSize(span, distance);
            document.getElementById('output-angular-size').textContent = `Angular Size: ${angularSize} degrees`;
        }

        in_objectDistance.forEach((input) => {
            input.addEventListener('input', function () {
                const newValue = isNaN(event.target.value) ? 0 : event.target.value;
                in_objectDistance.forEach((input) => {
                    input.value = newValue;
                });
                oD = newValue;
            });
        });
        in_imageDistance.forEach((input) => {
            input.addEventListener('input', function () {
                const newValue = isNaN(event.target.value) ? 0 : event.target.value;
                in_imageDistance.forEach((input) => {
                    input.value = newValue;
                });
                iD = newValue;
            });
        });
        in_span.forEach((input) => {
            input.addEventListener('input', function () {
                const newValue = isNaN(event.target.value) ? 0 : event.target.value;
                in_span.forEach((input) => {
                    input.value = newValue;
                });
                span = newValue;
            });
        });
        in_distance.forEach((input) => {
            input.addEventListener('input', function () {
                const newValue = isNaN(event.target.value) ? 0 : event.target.value;
                in_distance.forEach((input) => {
                    input.value = newValue;
                });
                distance = newValue;
            });
        });
        in_lensD.forEach((input) => {
            input.addEventListener('input', function () {
                const newValue = isNaN(event.target.value) ? 0 : event.target.value;
                in_lensD.forEach((input) => {
                    input.value = newValue;
                });
                lensD = newValue;
            });
        });
        in_lensF.forEach((input) => {
            input.addEventListener('input', function () {
                const newValue = isNaN(event.target.value) ? 0 : event.target.value;
                in_lensF.forEach((input) => {
                    input.value = newValue;
                });
                lensF = newValue;
            });
        });
        
        in_fov.forEach((input) => {
            input.addEventListener('input', function () {
                const newValue = isNaN(event.target.value) ? 0 : event.target.value;
                in_fov.forEach((input) => {
                    input.value = newValue;
                });
                fov = newValue;
            });
        });
        in_eyeR.forEach((input) => {
            input.addEventListener('input', function () {
                const newValue = isNaN(event.target.value) ? 0 : event.target.value;
                in_eyeR.forEach((input) => {
                    input.value = newValue;
                });
                eyeR = newValue;
            });
        });

    </script>
</body>
</html>
